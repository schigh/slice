package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"path"
	"strings"
	"text/template"
	"time"

	"github.com/schigh/slice"
	"github.com/schigh/slice/cmd/slicify/internal"
)

var (
	targetPackage string
	targetType    string
	targetFile    string
)

type fileParseResult int
const (
	foundNone fileParseResult = iota
	foundError
	foundStruct
	foundInterface
)

func main() {
	// make sure args are ok
	if len(os.Args) < 2 {
		internal.PrintErr("usage: slicify <struct> ...<funcs>")
		os.Exit(1)
	}

	// make sure env vars exist
	targetPackage = os.Getenv("GOPACKAGE")
	targetFile = os.Getenv("GOFILE")

	if targetPackage == "" || targetFile == "" {
		internal.PrintErr("both GOPACKAGE and GOFILE environment variables are required")
	}

	targetType = os.Args[1]
	// test for pointer
	var pointerOverride bool
	if targetType[0] == '*' {
		pointerOverride = true
		targetType = targetType[1:]
	}

	// assemble file path
	pwd, pwdErr := os.Getwd()
	if pwdErr != nil {
		internal.PrintErr("unable to get pwd: %v", pwdErr)
		os.Exit(1)
	}
	targetFile = path.Join(pwd, targetFile)

	found, parseErr := locateType(targetFile, targetType)
	if parseErr != nil {
		internal.PrintErr("error parsing file %s: %v", targetFile, parseErr)
		os.Exit(1)
	}

	switch found {
	case foundInterface:
		// force the pointer off
		if pointerOverride {
			pointerOverride = false
			internal.PrintInfo("ignoring pointer for interface type %s", targetType)
		}
	case foundNone:
		internal.PrintErr("unable to locate struct or interface %s in file %s", targetType, targetFile)
		os.Exit(1)
	}

	// inform user what is being created
	var pointerStr string
	if pointerOverride {
		pointerStr = "pointer "
	}
	internal.PrintInfo("generating %sslices for type %s in %s", pointerStr, targetType, path.Base(targetFile))

	// determine scope
	scope := slice.String(os.Args[2:]).Unique().Value()
	flags := strings.Join(scope, " ")
	operations, opsErr := internal.OperationsFromFlags(flags, found == foundInterface)
	if opsErr != nil {
		internal.PrintErr(opsErr.Error())
		os.Exit(1)
	}

	// add the header operation
	header := []internal.Operation{
		{
			Template: internal.HeadTmpl,
			Name:     "head",
		},
	}
	operations = append(header, operations...)

	t := &internal.Template{
		PO:           pointerOverride,
		PackageName:  targetPackage,
		GenDate:      time.Now().Format(time.RFC1123Z),
		SourceStruct: targetType,
		Operations:   operations,
	}

	fileBytes, outErr := generateOutBytes(t, pointerOverride)
	if outErr != nil {
		os.Exit(1)
	}

	// if it's a pointer slice, create a filename that indicates a pointer
	if pointerOverride {
		targetType = fmt.Sprintf("%s_ptr", targetType)
	}
	outfile := path.Join(path.Dir(targetFile), fmt.Sprintf("%s_slices.go", strings.ToLower(targetType)))
	if writeFileErr := ioutil.WriteFile(outfile, fileBytes, 0644); writeFileErr != nil {
		internal.PrintErr("error writing to file %s: %v", targetFile, writeFileErr)
		os.Exit(1)
	}

	internal.PrintSuccess("wrote file %s", outfile)
}

func locateType(filePath, targetType string) (fileParseResult, error) {
	fset := token.NewFileSet()
	node, parseErr := parser.ParseFile(fset, filePath, nil, parser.AllErrors)
	if parseErr != nil {
		return foundError, parseErr
	}

	var structFound, ifaceFound bool
	var typeName string

	ast.Inspect(node, func(n ast.Node) bool {
		switch t := n.(type) {
		case *ast.TypeSpec:
			typeName = t.Name.String()
		case *ast.StructType:
			if typeName == targetType {
				structFound = true
				return false
			}
		case *ast.InterfaceType:
			if typeName == targetType {
				ifaceFound = true
				return false
			}
		}
		return true
	})

	if structFound {
		return foundStruct, nil
	}
	if ifaceFound {
		return foundInterface, nil
	}

	return foundNone, nil
}

func generateOutBytes(tmpl *internal.Template, overridePtr bool) ([]byte, error) {
	var b []byte
	var bBuff *bytes.Buffer
	bBuff = bytes.NewBuffer(b)

	for _, op := range tmpl.Operations {
		op.SourceStruct = tmpl.SourceStruct
		op.SliceTypeName = tmpl.SourceStruct
		if overridePtr {
			op.SliceTypeName = fmt.Sprintf("%sPtr", op.SliceTypeName)
		}
		op.GenDate = tmpl.GenDate
		op.PackageName = tmpl.PackageName
		op.PO = tmpl.PO
		tm, tmErr := template.New(op.Name + op.SliceTypeName).Parse(op.Template.String())
		if tmErr != nil {
			internal.PrintErr("parsing template failed", tmErr)
			return nil, tmErr
		}
		if execErr := tm.Execute(bBuff, &op); execErr != nil {
			internal.PrintErr("executing template failed")
			return nil, execErr
		}
	}

	// format the generated bytes
	srcBytes, srcErr := format.Source(bBuff.Bytes())
	if srcErr != nil {
		internal.PrintErr("formatting generated source failed")
		return nil, srcErr
	}
	bBuff = bytes.NewBuffer(srcBytes)
	return bBuff.Bytes(), nil
}
