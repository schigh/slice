package internal

// Template encapsulates template params
type Template struct {
	PO           bool // pointer override
	PackageName  string
	GenDate      string
	SourceStruct string
	Operations   []Operation
}

// SliceTemplate aliases string
type SliceTemplate string

// String just returns the template's proper string value
func (t SliceTemplate) String() string {
	return string(t)
}

// HeadTmpl is the header template for all generated slice files
const HeadTmpl = SliceTemplate(`// Generated by slice (github.com/schigh/slice). DO NOT EDIT.

package {{.PackageName}}

// {{.SliceTypeName}}Slice aliases []{{if .PO}}*{{end}}{{.SourceStruct}}
type {{.SliceTypeName}}Slice []{{if .PO}}*{{end}}{{.SourceStruct}}

// Value returns the wrapped {{.SourceStruct}} slice
func (slc {{.SliceTypeName}}Slice) Value() []{{if .PO}}*{{end}}{{.SourceStruct}} {
	return []{{if .PO}}*{{end}}{{.SourceStruct}}(slc)
}

`)

// MapTmpl is the map function
const MapTmpl = SliceTemplate(`// Map applies a function to every {{.SourceStruct}} in the slice.  This function will mutate the slice in place{{if .PO}}
func (slc {{.SliceTypeName}}Slice) Map(f func(*{{.SourceStruct}}) *{{.SourceStruct}}) {
	for i := 0; i < len(slc); i++ {
		slc[i] = f(slc[i])
	}
}

{{else}}
func (slc {{.SliceTypeName}}Slice) Map(f func({{if .ByRef}}*{{end}}{{.SourceStruct}}) {{if .ByRef}}*{{end}}{{.SourceStruct}}) {
	for i := 0; i < len(slc); i++ {
		{{if .ByRef}}v := f(&slc[i])
		slc[i] = *v{{else}}slc[i] = f(slc[i]){{end}}
	}
}

{{end}}`)

// EachTmpl is the each function
const EachTmpl = SliceTemplate(`// Each applies a function to every {{.SourceStruct}} in the slice.{{if .PO}}
func (slc {{.SliceTypeName}}Slice) Each(f func(*{{.SourceStruct}})) {
	for i := 0; i < len(slc); i++ {
		f(slc[i])
	}
}

{{else}}
func (slc {{.SliceTypeName}}Slice) Each(f func({{if .ByRef}}*{{end}}{{.SourceStruct}})) {
	for i := 0; i < len(slc); i++ {
		f({{if .ByRef}}&{{end}}slc[i])
	}
}

{{end}}`)

// TryEachTmpl is the TryEach function
const TryEachTmpl = SliceTemplate(`// TryEach applies a function to every {{.SourceStruct}} in the slice,
// and returns the index of the element that caused the first error, and the error itself.  
// If every member of the slice returns nil, this function will return (-1, nil)
// The iteration will halt on the first error encountered and return it.{{if .PO}}
func (slc {{.SliceTypeName}}Slice) TryEach(f func(*{{.SourceStruct}}) error) (int, error) {
	for i := 0; i < len(slc); i++ {
		if err := f(slc[i]); err != nil {
			return i, err
		}
	}

	return -1, nil
}

{{else}}
func (slc {{.SliceTypeName}}Slice) TryEach(f func({{if .ByRef}}*{{end}}{{.SourceStruct}}) error) (int, error) {
	for i := 0; i < len(slc); i++ {
		if err := f({{if .ByRef}}&{{end}}slc[i]); err != nil {
			return i, err
		}
	}

	return -1, nil
}

{{end}}`)

// IfEachTmpl is the IfEach function
const IfEachTmpl = SliceTemplate(`// IfEach applies a function to every {{.SourceStruct}} in the slice,
// and returns the index of the element that caused the function to return false.  
// If every member of the slice evaluates to true, this function will return (-1, true)
// The iteration will halt on the first false return from the function.{{if .PO}}
func (slc {{.SliceTypeName}}Slice) IfEach(f func(*{{.SourceStruct}}) bool) (int, bool) {
	for i := 0; i < len(slc); i++ {
		if !f(slc[i]) {
			return i, false
		}
	}

	return -1, true
}

{{else}}
func (slc {{.SliceTypeName}}Slice) IfEach(f func({{if .ByRef}}*{{end}}{{.SourceStruct}}) bool) (int, bool) {
	for i := 0; i < len(slc); i++ {
		if !f({{if .ByRef}}&{{end}}slc[i]) {
			return i, false
		}
	}

	return -1, false
}

{{end}}`)

// FilterTmpl is the filter function
const FilterTmpl = SliceTemplate(`// Filter evaluates every element in the slice, and returns all {{.SourceStruct}} 
// instances where the eval function returns true{{if .PO}}
func (slc {{.SliceTypeName}}Slice) Filter(f func(*{{.SourceStruct}}) bool) {{.SliceTypeName}}Slice {
	out := make([]*{{.SourceStruct}}, 0, len(slc))
	for i := 0; i < len(slc); i++ {
		if f(slc[i]) {
			out = append(out, slc[i])
		}
	}

	return {{.SliceTypeName}}Slice(out)
}

{{else}}
func (slc {{.SliceTypeName}}Slice) Filter(f func({{if .ByRef}}*{{end}}{{.SourceStruct}}) bool) {{.SliceTypeName}}Slice {
	out := make([]{{.SourceStruct}}, 0, len(slc))
	for i := 0; i < len(slc); i++ {
		if f({{if .ByRef}}&{{end}}slc[i]) {
			out = append(out, slc[i])
		}
	}

	return {{.SliceTypeName}}Slice(out)
}

{{end}}`)

// ChunkTmpl is the chunk function
const ChunkTmpl = SliceTemplate(`// Chunk divides the slice into equally sized chunks
func (slc {{.SliceTypeName}}Slice) Chunk(size int) [][]{{if .PO}}*{{end}}{{.SourceStruct}} {
	l := len(slc)
	if l == 0 || size <= 0 {
		return make([][]{{if .PO}}*{{end}}{{.SourceStruct}}, 0)
	}

	floor := l / size
	out := make([][]{{if .PO}}*{{end}}{{.SourceStruct}}, 0, floor+1)
	var k int

	for i := 0; i < floor; i++ {
		k = i*size + size
		out = append(out, slc[i*size:k])
	}
	if l > k {
		out = append(out, slc[k:])
	}

	return out
}
`)
